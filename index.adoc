:toc: right
:backend: html5
:doctitle: Rung Documentation
:doctype: book
:icons: font
:!numbered:
:!linkcss:
:sectanchors:
:sectlink:
:docinfo:
:source-highlighter: highlightjs
:toclevels: 3
:hardbreaks:
:chapter-label: Chapter
:version-label: Version

= *Rung Documentation*

include::/home/circleci/project/target/cukedoctor-intro.adoc[leveloffset=+1]


[[Operation-definition, Operation definition]]
== *Operation definition*

ifndef::backend-pdf[]
minmax::Operation-definition[]
endif::[]
****
:!hardbreaks:
Operation defines a business process that consists of multiple steps.

For example when in e-commerce application new order is created then +
the system should update state of the warehouse, send an e-mail, create new waybill etc.

To define Operation create a new class based on `Rung::Base`.
Inside it you can define steps using Rung DSL.
Steps definition order is important as they are always executed in order.

Steps can communicate with each other and external world using State. When
operation is called then new state object is created (see link:#State[State]).
State is shared between step executions.

There are multiple ways of defining steps.
****

=== Steps can be defined as a Ruby block

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do |state|
    state[:what] = "World"
  end

  step do
    print_to_output "Hello "
  end

  step do |state|
    print_to_output state[:what]
  end

  step do
    print_to_output "!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== Steps can be defined as methods

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step :set_what_state
  step :print_hello
  step "print_what"
  step :print_bang

  def set_what_state(state)
    state[:what] = "World"
  end

  def print_hello
    print_to_output "Hello "
  end

  def print_what(state)
    print_to_output state[:what]
  end

  def print_bang
    print_to_output "!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== Steps can be defined as any objects with call method

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class SetWhatState
  def initialize(what)
    @what = what
  end

  def call(state)
    state[:what] = @what
  end
end

class PrintHello
  def self.call
    print_to_output "Hello "
  end
end

class PrintWhat
  def self.call(state)
    print_to_output state[:what]
  end
end

PrintBang = -> { print_to_output "!" }

class Operation < Rung::Base
  step SetWhatState.new("World")
  step PrintHello
  step PrintWhat
  step PrintBang
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

[[Success-and-failure, Success and failure]]
== *Success and failure*

ifndef::backend-pdf[]
minmax::Success-and-failure[]
endif::[]
****
:!hardbreaks:
Value returned from step call is important. Successful step should
return truthy value (anything other than `false` or `nil`).

If step returns falsy value (`false` or `nil`) then
the operation is marked as failed. All next steps are not executed.

Result of the Operation call (`Rung::Runner::Result` object)
can be either a success or a failure. Result has `success?` and `failure?` methods.
****

=== When all steps return truthy value the result is a success

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    # do something...
    true
  end

  step :second_step

  def second_step
    2 + 2
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.success? == true

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure? == false

----
==========

=== When at least one step returns a falsy value then the result is a failure

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    # do something...
    true
  end

  step :second_step

  def second_step
    nil
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.success? == false

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure? == true

----
==========

=== When a step fails then the next steps are not executed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Hello"
    true
  end

  step do
    # something went wrong, retuning false
    false
  end

  step do
    print_to_output "World"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello

----
==========

[[State, State]]
== *State*

ifndef::backend-pdf[]
minmax::State[]
endif::[]
****
:!hardbreaks:
State is a Hash object that is shared between step executions.

It's used to share state between steps and communicate with external world.

User can provide initial state when calling the operation. By default it's empty.

State can be used as the operation output as it is accessible in the result object.
****

=== State is shared across step executions

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do |state|
    state[:what] = "World!"
  end

  step do
    print_to_output "Hello "
  end

  step do |state|
    print_to_output state[:what]
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== State is available in the result object

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do |state|
    state[:output_text] = "Hello "
  end

  step do |state|
    state[:output_text] << "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result[:output_text] == "Hello World!"

----
==========

=== Initial state can be passed to call method

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do |state|
    state[:output_text] << "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call(output_text: "Hello ")

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result[:output_text] == "Hello World!"

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.state == { output_text: "Hello World!" }

----
==========

[[Failure-Step, Failure Step]]
== *Failure Step*

ifndef::backend-pdf[]
minmax::Failure-Step[]
endif::[]
****
:!hardbreaks:
When operations fails (see link:#Success-and-failure[Success and failure])
next normal steps are no ignored and not executed.

There's a way to react to a failure with special failure steps.

Failure steps can be defined similarly to normal steps (as a block, method, or a callable object).
****

=== Failure step is executed when operation fails

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Working..."
    # something went wrong...
    false
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Oops!

----
==========

=== Failure step is not executed when operation doesn't fail

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Working..."
    # everything's fine
    true
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working...

----
==========

=== It's possible to define multiple failure steps

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do |state|
    print_to_output "Working..."
    # something went wrong...
    state[:error] = "404"
    false
  end

  failure do
    print_to_output " Error: "
  end

  failure do |state|
    print_to_output state[:error]
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Error: 404

----
==========

=== Failure step is executed only when it's defined after failed step

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  failure do
    print_to_output "Something's wrong"
  end

  step do
    print_to_output "Working..."
    # something went wrong...
    false
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Oops!

----
==========

[[Other-steps, Other steps]]
== *Other steps*

ifndef::backend-pdf[]
minmax::Other-steps[]
endif::[]
****
:!hardbreaks:

`step` and `failure` are the basic step types.
For the convenience there are also two additional step
types defined:

* `tee` - works the same way as `step` but ignores the return value
* `always` - executes on both success and failure. Return value is not checked

.Table Step behaviours
|===
|Step name|Execute on success|Execute on failure|Ignore return value

|step|✓|✗|✗
|failure|✗|✓|✓
|tee|✓|✗|✓
|always|✓|✓|✓
****

=== `tee` step result is not checked

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  tee do
    print_to_output "Hello "
    false
  end

  step do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== `tee` is not executed when operation is failed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Hello"
    false # fail
  end

  tee do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello

----
==========

=== `always` is called when operation is successful

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Hello "
  end

  always do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== `always` is called when operation is failed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Hello "
    false # fail
  end

  always do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== state object provides information about operation success with `success?` and `fail?`

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  step do
    print_to_output "Hello"
    false # fail
  end

  always do |state|
    print_to_output " World!" if state.success?
    print_to_output " There!" if state.fail?
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello There!

----
==========

[[Step-wrappers, Step wrappers]]
== *Step wrappers*

ifndef::backend-pdf[]
minmax::Step-wrappers[]
endif::[]
****
:!hardbreaks:
It's possible to wrap around a group of successive steps
with `wrap`.
This is a common use case for surrounding multiple steps in
a database transaction and rolling back when steps inside fail.

Wrapper interface is the same as for any other step.
It requires an object responding to `call()` or `call(state)`.
The only difference is that it also receives a block.

Yielding the block calls inner steps. It returns `false` if
any of the inner steps failed or `true` otherwise.

Example usage:
```ruby
class Operation < Rung::Base
  class TransactionWrapper
    def self.call(state)
      return if state.fail?
      ActiveRecord::Base.transaction do
        success = yield
        raise ActiveRecord::Rollback unless success
      end
    end
  end

  wrap TransactionWrapper do
    step :create_new_entity
    step :update_counter
  end
end
```
****

=== Defining a wrapper that prints before and after step calls

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Base
  class Wrapper
    def self.call
      print_to_output "Starting\n"
      success = yield
      if success
        print_to_output "\nSuccess!"
      else
        print_to_output "\nFailure!"
      end
    end
  end

  wrap Wrapper do
    step { print_to_output "Hello " }
    step do |state|
      print_to_output "World!"
      state[:variable] # return variable passed by the user
    end
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: true)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Starting
Hello World!
Success!

----
Then ::
I clear output icon:thumbs-up[role="green",title="Passed"]
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: false)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Starting
Hello World!
Failure!

----
==========

