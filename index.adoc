:toc: right
:backend: html5
:doctitle: Rung Documentation
:doctype: book
:icons: font
:!numbered:
:!linkcss:
:sectanchors:
:sectlink:
:docinfo:
:source-highlighter: highlightjs
:toclevels: 3
:hardbreaks:
:chapter-label: Chapter
:version-label: Version

= *Rung Documentation*

include::/home/circleci/project/target/cukedoctor-intro.adoc[leveloffset=+1]


[[Operation-definition, Operation definition]]
== *Operation definition*

ifndef::backend-pdf[]
minmax::Operation-definition[]
endif::[]
****
:!hardbreaks:
Operation defines a business process that consists of multiple steps.

For example when in e-commerce application new order is created then +
the system should update state of the warehouse, send an e-mail, create new waybill etc.

To define Operation create a new class based on `Rung::Operation`.
Inside it you can define steps using Rung DSL.
Steps definition order is important as they are always executed in order.

Steps can communicate with each other and external world using State. When
operation is called then new state object is created (see link:#State[State]).
State is shared between step executions.

There are multiple ways of defining steps.
****

=== Steps can be defined as a Ruby block

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do |state|
    state[:what] = "World"
  end

  step do
    print_to_output "Hello "
  end

  step do |state|
    print_to_output state[:what]
  end

  step do
    print_to_output "!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== Steps can be defined as methods

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step :set_what_state
  step :print_hello
  step "print_what"
  step :print_bang

  def set_what_state(state)
    state[:what] = "World"
  end

  def print_hello
    print_to_output "Hello "
  end

  def print_what(state)
    print_to_output state[:what]
  end

  def print_bang
    print_to_output "!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== Steps can be defined as any objects with call method

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class SetWhatState
  def initialize(what)
    @what = what
  end

  def call(state)
    state[:what] = @what
  end
end

class PrintHello
  def self.call
    print_to_output "Hello "
  end
end

class PrintWhat
  def self.call(state)
    print_to_output state[:what]
  end
end

PrintBang = -> { print_to_output "!" }

class Operation < Rung::Operation
  step SetWhatState.new("World")
  step PrintHello
  step PrintWhat
  step PrintBang
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

[[Success-and-failure, Success and failure]]
== *Success and failure*

ifndef::backend-pdf[]
minmax::Success-and-failure[]
endif::[]
****
:!hardbreaks:
Value returned from step call is important. Successful step should
return truthy value (anything other than `false` or `nil`).

If step returns falsy value (`false` or `nil`) then
the operation is marked as failed. All next steps are not executed.

Result of the Operation call (`Rung::Runner::Result` object)
can be either a success or a failure. Result has `success?` and `failure?` methods.
****

=== When all steps return truthy value the result is a success

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    # do something...
    true
  end

  step :second_step

  def second_step
    2 + 2
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.success? == true

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure? == false

----
==========

=== When at least one step returns a falsy value then the result is a failure

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    # do something...
    true
  end

  step :second_step

  def second_step
    nil
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.success? == false

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure? == true

----
==========

=== When a step fails then the next steps are not executed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello"
    true
  end

  step do
    # something went wrong, retuning false
    false
  end

  step do
    print_to_output "World"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello

----
==========

[[State, State]]
== *State*

ifndef::backend-pdf[]
minmax::State[]
endif::[]
****
:!hardbreaks:
State is a Hash object that is shared between step executions.

It's used to share state between steps and communicate with external world.

User can provide initial state when calling the operation. By default it's empty.

State can be used as the operation output as it is accessible in the result object.
****

=== State is shared across step executions

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do |state|
    state[:what] = "World!"
  end

  step do
    print_to_output "Hello "
  end

  step do |state|
    print_to_output state[:what]
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== State is available in the result object

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do |state|
    state[:output_text] = "Hello "
  end

  step do |state|
    state[:output_text] << "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result[:output_text] == "Hello World!"

----
==========

=== Initial state can be passed to call method

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do |state|
    state[:output_text] << "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call(output_text: "Hello ")

----
Then ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result[:output_text] == "Hello World!"

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.to_h == { output_text: "Hello World!" }

----
==========

[[Failure-Step, Failure Step]]
== *Failure Step*

ifndef::backend-pdf[]
minmax::Failure-Step[]
endif::[]
****
:!hardbreaks:
When operations fails (see link:#Success-and-failure[Success and failure])
next normal steps are no ignored and not executed.

There's a way to react to a failure with special failure steps.

Failure steps can be defined similarly to normal steps (as a block, method, or a callable object).
****

=== Failure step is executed when operation fails

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Working..."
    # something went wrong...
    false
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Oops!

----
==========

=== Failure step is not executed when operation doesn't fail

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Working..."
    # everything's fine
    true
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working...

----
==========

=== It's possible to define multiple failure steps

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do |state|
    print_to_output "Working..."
    # something went wrong...
    state[:error] = "404"
    false
  end

  failure do
    print_to_output " Error: "
  end

  failure do |state|
    print_to_output state[:error]
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Error: 404

----
==========

=== Failure step is executed only when it's defined after failed step

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  failure do
    print_to_output "Something's wrong"
  end

  step do
    print_to_output "Working..."
    # something went wrong...
    false
  end

  failure do
    print_to_output " Oops!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Working... Oops!

----
==========

[[Other-steps, Other steps]]
== *Other steps*

ifndef::backend-pdf[]
minmax::Other-steps[]
endif::[]
****
:!hardbreaks:

`step` and `failure` are the basic step types.
For the convenience there are also two additional step
types defined:

* `tee` - works the same way as `step` but ignores the return value
* `always` - executes on both success and failure. Return value is not checked

.Table Step behaviours
|===
|Step name|Execute on success|Execute on failure|Ignore return value

|step|✓|✗|✗
|failure|✗|✓|✓
|tee|✓|✗|✓
|always|✓|✓|✓
****

=== `tee` step result is not checked

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  tee do
    print_to_output "Hello "
    false
  end

  step do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== `tee` is not executed when operation is failed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello"
    false # fail
  end

  tee do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello

----
==========

=== `always` is called when operation is successful

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello "
  end

  always do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== `always` is called when operation is failed

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello "
    false # fail
  end

  always do
    print_to_output "World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!

----
==========

=== state object provides information about operation success with `success?` and `fail?`

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello"
    false # fail
  end

  always do |state|
    print_to_output " World!" if state.success?
    print_to_output " There!" if state.fail?
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello There!

----
==========

[[Fail-fast, Fail fast]]
== *Fail fast*

ifndef::backend-pdf[]
minmax::Fail-fast[]
endif::[]
=== When step with `fail_fast` fails the execution is immediately stopped

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step(fail_fast: true) do
    print_to_output "Hello"
    false
  end

  step do
    print_to_output " World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure?

----
==========

=== Any kind of step can use `fail_fast`

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step do
    print_to_output "Hello"
    false
  end

  failure fail_fast: true do
    print_to_output "...Goodbye!"
  end

  step do
    print_to_output " World!"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello...Goodbye!

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.failure?

----
==========

[[Step-wrappers, Step wrappers]]
== *Step wrappers*

ifndef::backend-pdf[]
minmax::Step-wrappers[]
endif::[]
****
:!hardbreaks:
It's possible to step around a group of successive steps.
This is a common use case for surrounding multiple steps in
a database transaction and rolling back when steps inside fail.

Steps wrapper is defined as a step (of any type, e.g. `step` or `tee`)
with callable wrapper-action and additional
block defining nested steps.

Wrapper-action is a Callable or method name.

Yielding the block calls inner steps. Yield returns `false` if
any of the inner steps failed or `true` otherwise.

Example usage:
```ruby
class Operation < Rung::Operation
  class TransactionWrapper
    def self.call(state)
      return if state.fail?
      ActiveRecord::Base.transaction do
        success = yield
        raise ActiveRecord::Rollback unless success
        true
      end
    end
  end

  step TransactionWrapper do
    step :create_new_entity
    step :update_counter
  end
end
```
****

=== Wrapper can yield to execute inner steps

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Wrapper
    def self.call
      print_to_output "Starting\n"
      success = yield
      if success
        print_to_output "\nSuccess!"
      else
        print_to_output "\nFailure!"
      end
    end
  end

  step Wrapper do
    step { print_to_output "Hello " }
    step do |state|
      print_to_output "World!"
      state[:variable] # return variable passed by the user
    end
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: true)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Starting
Hello World!
Success!

----
Then ::
I clear output icon:thumbs-up[role="green",title="Passed"]
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: false)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Starting
Hello World!
Failure!

----
==========

=== Wrappers can be nested

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Wrapper
    def initialize(name)
      @name = name
    end

    def call
      print_to_output "Starting #{@name}\n"
      yield
      print_to_output "Finishing #{@name}\n"
    end
  end

  step Wrapper.new("first") do
    step { print_to_output "Hello\n" }
    step Wrapper.new("second") do
      step { print_to_output "Hi\n" }
    end
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Starting first
Hello
Starting second
Hi
Finishing second
Finishing first


----
==========

=== step type is important when calling a wrapper

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Wrapper
    def initialize(name)
      @name = name
    end

    def call
      print_to_output "from: #{@name}\n"
      yield
    end
  end

  step do
    print_to_output "RED ALERT\n"
    false
  end

  step Wrapper.new("OK") do
    step { print_to_output "Hurray!\n" }
  end

  failure Wrapper.new("FAIL") do
    failure { print_to_output "Oops!\n" }
  end

  always Wrapper.new("ALWAYS") do
    step { print_to_output "We're done!\n" }
    failure { print_to_output "We're done, but something went wrong!\n" }
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: true)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

RED ALERT
from: FAIL
Oops!
from: ALWAYS
We're done, but something went wrong!


----
==========

[[Operation-wrappers, Operation wrappers]]
== *Operation wrappers*

ifndef::backend-pdf[]
minmax::Operation-wrappers[]
endif::[]
****
:!hardbreaks:
It is possible to define global wrappers on the Operation level using `around` call.
****

=== Operation can have multiple global wrappers
  Wrappers are called in the order they are defined.

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Wrapper
    def initialize(name)
      @name = name
    end

    def call
      print_to_output "#{@name} start\n"
      yield
      print_to_output "#{@name} done\n"
    end
  end

  around Wrapper.new("1")
  around Wrapper.new("2")

  step { print_to_output "Hello World!\n" }
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call(variable: true)

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

1 start
2 start
Hello World!
2 done
1 done


----
==========

[[Exceptions-handling, Exceptions handling]]
== *Exceptions handling*

ifndef::backend-pdf[]
minmax::Exceptions-handling[]
endif::[]
=== All exceptions are raised

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step { raise "Oh no!" }
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

begin
  Operation.new.call(output_text: "Hello ")
rescue => e
  print_to_output e.message
end

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Oh no!

----
==========

=== Exception can be caught in a wrapper

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Wrapper
    def self.call(state)
      yield
    rescue
      print_to_output "Exception handled"
      state[:exception_handled] = true
    end
  end

  around Wrapper

  step { print_to_output "Hello World!\n"; raise "oops!" }
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello World!
Exception handled

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.to_h == { exception_handled: true }

----
==========

[[Around-step-wrapper, Around step wrapper]]
== *Around step wrapper*

ifndef::backend-pdf[]
minmax::Around-step-wrapper[]
endif::[]
****
:!hardbreaks:
****

=== Step wrapper is called for every step

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Counter
    def initialize
      @count = 0
    end

    def call
      @count += 1
      print_to_output "Step #{@count}\n"
      yield
    end
  end

  around_each Counter.new

  step do
    print_to_output "Hello\n"
  end

  step do
    print_to_output "World\n"
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Step 1
Hello
Step 2
World


----
==========

=== Step wrapper receives state and current step

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Logger
    def self.call(state, step)
      result = yield

      print_to_output "State: #{state.to_h}, success: #{state.success?}," \
        "ignores result: #{step.ignore_result?}, nested: #{step.nested?}, result: #{result}\n"

      result
    end
  end

  noop_wrapper = -> (&block) { block.call }

  around_each Logger

  step do |state|
    print_to_output "Hello\n"
    state[:test] = 42
  end

  step noop_wrapper do
    tee do |state|
      state[:test] = 5
      print_to_output "World\n"
      true
    end
  end
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello
State: {:test=>42}, success: true,ignores result: false, nested: false, result: 42
World
State: {:test=>5}, success: true,ignores result: true, nested: false, result: true
State: {:test=>5}, success: true,ignores result: false, nested: true, result: true


----
==========

=== Step wrapper returned result is treated as the step result

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  class Boom
    def self.call(state)
      yield
      print_to_output "Boom!\n"
      false # always return false
    end
  end

  around_each Boom

  tee do |state| # tee step ignores result, so Boom doesn't affect it
    print_to_output "Hello\n"
  end

  step { print_to_output "Beautiful\n" }
  step { print_to_output "World\n" }
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result = Operation.new.call

----
Then ::
I see output icon:thumbs-up[role="green",title="Passed"]
----

Hello
Boom!
Beautiful
Boom!


----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result.success? == false

----
==========

[[Misc, Misc]]
== *Misc*

ifndef::backend-pdf[]
minmax::Misc[]
endif::[]
=== Operation defines .call shorthand class method

==========
Given ::
definition icon:thumbs-up[role="green",title="Passed"]
----

class Operation < Rung::Operation
  step {|state| state[:test] = 42 + state[:input] }
end

----
When ::
I run icon:thumbs-up[role="green",title="Passed"]
----

@result1 = Operation.call(input: 1)
@result2 = Operation.new.call(input: 1)

----
And ::
I can assure that icon:thumbs-up[role="green",title="Passed"]
----

@result1.to_h == @result2.to_h

----
==========

